{
    "original code": "/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE476_NULL_Pointer_Dereference__binary_if_08.java\nLabel Definition File: CWE476_NULL_Pointer_Dereference.pointflaw.label.xml\nTemplate File: point-flaw-08.tmpl.java\n*/\n/*\n* @description\n* CWE: 476 NULL Pointer Dereference\n* Sinks: binary_if\n*    GoodSink: Do not check for null after the object has been dereferenced\n*    BadSink : Check for null after an object has already been dereferenced\n* Flow Variant: 08 Control flow: if(privateReturnsTrue()) and if(privateReturnsFalse())\n*\n* */\n\npackage testcases.CWE476_NULL_Pointer_Dereference;\n\nimport testcasesupport.*;\n\npublic class CWE476_NULL_Pointer_Dereference__binary_if_08 extends AbstractTestCase\n{\n    /* The methods below always return the same value, so a tool\n     * should be able to figure out that every call to these\n     * methods will return true or return false.\n     */\n    private boolean privateReturnsTrue()\n    {\n        return true;\n    }\n\n    private boolean privateReturnsFalse()\n    {\n        return false;\n    }\n\n    public void bad() throws Throwable\n    {\n        if (privateReturnsTrue())\n        {\n            {\n                String myString = null;\n                /* FLAW: Using a single & in the if statement will cause both sides of the expression to be evaluated\n                 * thus causing a NPD */\n                if ((myString != null) & (myString.length() > 0))\n                {\n                    IO.writeLine(\"The string length is greater than 0\");\n                }\n            }\n        }\n    }\n\n    /* good1() changes privateReturnsTrue() to privateReturnsFalse() */\n    private void good1() throws Throwable\n    {\n        if (privateReturnsFalse())\n        {\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n            IO.writeLine(\"Benign, fixed string\");\n        }\n        else\n        {\n\n            {\n                String myString = null;\n\n                /* FIX: Use && in the if statement so that if the left side of the expression fails then\n                 * the right side will not be evaluated */\n                if ((myString != null) && (myString.length() > 0))\n                {\n                    IO.writeLine(\"The string length is greater than 0\");\n                }\n            }\n\n        }\n    }\n\n    /* good2() reverses the bodies in the if statement */\n    private void good2() throws Throwable\n    {\n        if (privateReturnsTrue())\n        {\n            {\n                String myString = null;\n                /* FIX: Use && in the if statement so that if the left side of the expression fails then\n                 * the right side will not be evaluated */\n                if ((myString != null) && (myString.length() > 0))\n                {\n                    IO.writeLine(\"The string length is greater than 0\");\n                }\n            }\n        }\n    }\n\n    public void good() throws Throwable\n    {\n        good1();\n        good2();\n    }\n\n    /* Below is the main(). It is only used when building this testcase on\n     * its own for testing or for building a binary to use in testing binary\n     * analysis tools. It is not used when compiling all the testcases as one\n     * application, which is how source code analysis tools are tested.\n     */\n    public static void main(String[] args) throws ClassNotFoundException,\n           InstantiationException, IllegalAccessException\n    {\n        mainFromParent(args);\n    }\n}\n",
    "analyzed code": "1  \n2  \n3  \n4  \n5  \n6  \n7  \n8  \n9  \n10  \n11  \n12  \n13  \n14  \n15  \n16  package testcases.CWE476_NULL_Pointer_Dereference;\n17  \n18  import testcasesupport.*;\n19  \n20  public class CWE476_NULL_Pointer_Dereference__binary_if_08 extends AbstractTestCase\n21  {\n22      \n23  \n24  \n25  \n26      private boolean privateReturnsTrue()\n27      {\n28          return true;\n29      }\n30  \n31      private boolean privateReturnsFalse()\n32      {\n33          return false;\n34      }\n35  \n36      public void hoo() throws Throwable\n37      {\n38          if (privateReturnsTrue())\n39          {\n40              {\n41                  String myString = null;\n42                  \n43  \n44                  if ((myString != null) & (myString.length() > 0))\n45                  {\n46                      IO.writeLine(\"The string length is greater than 0\");\n47                  }\n48              }\n49          }\n50      }\n51  \n52      \n53      private void foo1() throws Throwable\n54      {\n55          if (privateReturnsFalse())\n56          {\n57              \n58              IO.writeLine(\"Benign, fixed string\");\n59          }\n60          else\n61          {\n62  \n63              {\n64                  String myString = null;\n65  \n66                  \n67  \n68                  if ((myString != null) && (myString.length() > 0))\n69                  {\n70                      IO.writeLine(\"The string length is greater than 0\");\n71                  }\n72              }\n73  \n74          }\n75      }\n76  \n77      \n78      private void foo2() throws Throwable\n79      {\n80          if (privateReturnsTrue())\n81          {\n82              {\n83                  String myString = null;\n84                  \n85  \n86                  if ((myString != null) && (myString.length() > 0))\n87                  {\n88                      IO.writeLine(\"The string length is greater than 0\");\n89                  }\n90              }\n91          }\n92      }\n93  \n94      public void foo() throws Throwable\n95      {\n96          foo1();\n97          foo2();\n98      }\n99  \n100      \n101  \n102  \n103  \n104  \n105      public static void main(String[] args) throws ClassNotFoundException,\n106             InstantiationException, IllegalAccessException\n107      {\n108          mainFromParent(args);\n109      }\n110  }\n111  ",
    "trace_check_results": [
        {
            "trace": [
                [
                    41,
                    "myString"
                ],
                [
                    44,
                    "myString"
                ]
            ],
            "result": {
                "type_sanitize": 1,
                "functionality_sanitize": 0,
                "order_sanitize": 1,
                "reachability_sanitize": 1,
                "total": 1,
                "final": 0
            }
        },
        {
            "trace": [
                [
                    64,
                    "myString"
                ],
                [
                    68,
                    "myString"
                ]
            ],
            "result": {
                "type_sanitize": 1,
                "functionality_sanitize": 0,
                "order_sanitize": 1,
                "reachability_sanitize": 1,
                "total": 1,
                "final": 0
            }
        },
        {
            "trace": [
                [
                    83,
                    "myString"
                ],
                [
                    86,
                    "myString"
                ]
            ],
            "result": {
                "type_sanitize": 1,
                "functionality_sanitize": 0,
                "order_sanitize": 1,
                "reachability_sanitize": 1,
                "total": 1,
                "final": 0
            }
        }
    ]
}