{
    "original code": "/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE80_XSS__CWE182_Servlet_database_21.java\nLabel Definition File: CWE80_XSS__CWE182_Servlet.label.xml\nTemplate File: sources-sink-21.tmpl.java\n*/\n/*\n * @description\n * CWE: 80 Cross Site Scripting (XSS)\n * BadSource: database Read data from a database\n * GoodSource: A hardcoded string\n * Sinks:\n *    BadSink : Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS (CWE 182: Collapse of Data into Unsafe Value)\n * Flow Variant: 21 Control flow: Flow controlled by value of a private variable. All functions contained in one file.\n *\n * */\n\npackage testcases.CWE80_XSS.s01;\nimport testcasesupport.*;\n\nimport javax.servlet.http.*;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\nimport java.util.logging.Level;\n\npublic class CWE80_XSS__CWE182_Servlet_database_21 extends AbstractTestCaseServlet\n{\n    /* The variable below is used to drive control flow in the source function */\n    private boolean badPrivate = false;\n\n    public void bad(HttpServletRequest request, HttpServletResponse response) throws Throwable\n    {\n        String data;\n\n        badPrivate = true;\n        data = bad_source(request, response);\n\n        if (data != null)\n        {\n            /* POTENTIAL FLAW: Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS with strings like <scr<script>ipt> (CWE 182: Collapse of Data into Unsafe Value) */\n            response.getWriter().println(\"<br>bad(): data = \" + data.replaceAll(\"(<script>)\", \"\"));\n        }\n\n    }\n\n    private String bad_source(HttpServletRequest request, HttpServletResponse response) throws Throwable\n    {\n        String data;\n\n        if (badPrivate)\n        {\n            data = \"\"; /* Initialize data */\n            /* Read data from a database */\n            {\n                Connection connection = null;\n                PreparedStatement preparedStatement = null;\n                ResultSet resultSet = null;\n                try\n                {\n                    /* setup the connection */\n                    connection = IO.getDBConnection();\n                    /* prepare and execute a (hardcoded) query */\n                    preparedStatement = connection.prepareStatement(\"select name from users where id=0\");\n                    resultSet = preparedStatement.executeQuery();\n                    /* POTENTIAL FLAW: Read data from a database query resultset */\n                    data = resultSet.getString(1);\n                }\n                catch (SQLException exceptSql)\n                {\n                    IO.logger.log(Level.WARNING, \"Error with SQL statement\", exceptSql);\n                }\n                finally\n                {\n                    /* Close database objects */\n                    try\n                    {\n                        if (resultSet != null)\n                        {\n                            resultSet.close();\n                        }\n                    }\n                    catch (SQLException exceptSql)\n                    {\n                        IO.logger.log(Level.WARNING, \"Error closing ResultSet\", exceptSql);\n                    }\n\n                    try\n                    {\n                        if (preparedStatement != null)\n                        {\n                            preparedStatement.close();\n                        }\n                    }\n                    catch (SQLException exceptSql)\n                    {\n                        IO.logger.log(Level.WARNING, \"Error closing PreparedStatement\", exceptSql);\n                    }\n\n                    try\n                    {\n                        if (connection != null)\n                        {\n                            connection.close();\n                        }\n                    }\n                    catch (SQLException exceptSql)\n                    {\n                        IO.logger.log(Level.WARNING, \"Error closing Connection\", exceptSql);\n                    }\n                }\n            }\n        }\n        else\n        {\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run\n             * but ensure data is inititialized before the Sink to avoid compiler errors */\n            data = null;\n        }\n\n        return data;\n    }\n\n    /* The variables below are used to drive control flow in the source functions. */\n    private boolean goodG2B1_private = false;\n    private boolean goodG2B2_private = false;\n\n    public void good(HttpServletRequest request, HttpServletResponse response) throws Throwable\n    {\n        goodG2B1(request, response);\n        goodG2B2(request, response);\n    }\n\n    /* goodG2B1() - use goodsource and badsink by setting the variable to false instead of true */\n    private void goodG2B1(HttpServletRequest request, HttpServletResponse response) throws Throwable\n    {\n        String data;\n\n        goodG2B1_private = false;\n        data = goodG2B1_source(request, response);\n\n        if (data != null)\n        {\n            /* POTENTIAL FLAW: Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS with strings like <scr<script>ipt> (CWE 182: Collapse of Data into Unsafe Value) */\n            response.getWriter().println(\"<br>bad(): data = \" + data.replaceAll(\"(<script>)\", \"\"));\n        }\n\n    }\n\n    private String goodG2B1_source(HttpServletRequest request, HttpServletResponse response) throws Throwable\n    {\n        String data = null;\n\n        if (goodG2B1_private)\n        {\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run\n             * but ensure data is inititialized before the Sink to avoid compiler errors */\n            data = null;\n        }\n        else\n        {\n\n            /* FIX: Use a hardcoded string */\n            data = \"foo\";\n\n        }\n\n        return data;\n    }\n\n    /* goodG2B2() - use goodsource and badsink by reversing the blocks in the if in the sink function */\n    private void goodG2B2(HttpServletRequest request, HttpServletResponse response) throws Throwable\n    {\n        String data;\n\n        goodG2B2_private = true;\n        data = goodG2B2_source(request, response);\n\n        if (data != null)\n        {\n            /* POTENTIAL FLAW: Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS with strings like <scr<script>ipt> (CWE 182: Collapse of Data into Unsafe Value) */\n            response.getWriter().println(\"<br>bad(): data = \" + data.replaceAll(\"(<script>)\", \"\"));\n        }\n\n    }\n\n    private String goodG2B2_source(HttpServletRequest request, HttpServletResponse response) throws Throwable\n    {\n        String data = null;\n\n        if (goodG2B2_private)\n        {\n            /* FIX: Use a hardcoded string */\n            data = \"foo\";\n        }\n        else\n        {\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run\n             * but ensure data is inititialized before the Sink to avoid compiler errors */\n            data = null;\n        }\n\n        return data;\n    }\n\n    /* Below is the main(). It is only used when building this testcase on\n     * its own for testing or for building a binary to use in testing binary\n     * analysis tools. It is not used when compiling all the testcases as one\n     * application, which is how source code analysis tools are tested.\n     */\n    public static void main(String[] args) throws ClassNotFoundException,\n           InstantiationException, IllegalAccessException\n    {\n        mainFromParent(args);\n    }\n\n}\n",
    "analyzed code": "1  \n2  \n3  \n4  \n5  \n6  \n7  \n8  \n9  \n10  \n11  \n12  \n13  \n14  \n15  \n16  \n17  package testcases.CWE80_XSS.s01;\n18  import testcasesupport.*;\n19  \n20  import javax.servlet.http.*;\n21  \n22  import java.sql.Connection;\n23  import java.sql.PreparedStatement;\n24  import java.sql.ResultSet;\n25  import java.sql.SQLException;\n26  \n27  import java.util.logging.Level;\n28  \n29  public class CWE80_XSS__CWE182_Servlet_database_21 extends AbstractTestCaseServlet\n30  {\n31      \n32      private boolean hooPrivate = false;\n33  \n34      public void hoo(HttpServletRequest request, HttpServletResponse response) throws Throwable\n35      {\n36          String data;\n37  \n38          hooPrivate = true;\n39          data = hoo_source(request, response);\n40  \n41          if (data != null)\n42          {\n43              \n44              response.getWriter().println(\"<br>hoo(): data = \" + data.replaceAll(\"(<script>)\", \"\"));\n45          }\n46  \n47      }\n48  \n49      private String hoo_source(HttpServletRequest request, HttpServletResponse response) throws Throwable\n50      {\n51          String data;\n52  \n53          if (hooPrivate)\n54          {\n55              data = \"\"; \n56              \n57              {\n58                  Connection connection = null;\n59                  PreparedStatement preparedStatement = null;\n60                  ResultSet resultSet = null;\n61                  try\n62                  {\n63                      \n64                      connection = IO.getDBConnection();\n65                      \n66                      preparedStatement = connection.prepareStatement(\"select name from users where id=0\");\n67                      resultSet = preparedStatement.executeQuery();\n68                      \n69                      data = resultSet.getString(1);\n70                  }\n71                  catch (SQLException exceptSql)\n72                  {\n73                      IO.logger.log(Level.WARNING, \"Error with SQL statement\", exceptSql);\n74                  }\n75                  finally\n76                  {\n77                      \n78                      try\n79                      {\n80                          if (resultSet != null)\n81                          {\n82                              resultSet.close();\n83                          }\n84                      }\n85                      catch (SQLException exceptSql)\n86                      {\n87                          IO.logger.log(Level.WARNING, \"Error closing ResultSet\", exceptSql);\n88                      }\n89  \n90                      try\n91                      {\n92                          if (preparedStatement != null)\n93                          {\n94                              preparedStatement.close();\n95                          }\n96                      }\n97                      catch (SQLException exceptSql)\n98                      {\n99                          IO.logger.log(Level.WARNING, \"Error closing PreparedStatement\", exceptSql);\n100                      }\n101  \n102                      try\n103                      {\n104                          if (connection != null)\n105                          {\n106                              connection.close();\n107                          }\n108                      }\n109                      catch (SQLException exceptSql)\n110                      {\n111                          IO.logger.log(Level.WARNING, \"Error closing Connection\", exceptSql);\n112                      }\n113                  }\n114              }\n115          }\n116          else\n117          {\n118              \n119  \n120              data = null;\n121          }\n122  \n123          return data;\n124      }\n125  \n126      \n127      private boolean fooxx1_private = false;\n128      private boolean fooxx2_private = false;\n129  \n130      public void foo(HttpServletRequest request, HttpServletResponse response) throws Throwable\n131      {\n132          fooxx1(request, response);\n133          fooxx2(request, response);\n134      }\n135  \n136      \n137      private void fooxx1(HttpServletRequest request, HttpServletResponse response) throws Throwable\n138      {\n139          String data;\n140  \n141          fooxx1_private = false;\n142          data = fooxx1_source(request, response);\n143  \n144          if (data != null)\n145          {\n146              \n147              response.getWriter().println(\"<br>hoo(): data = \" + data.replaceAll(\"(<script>)\", \"\"));\n148          }\n149  \n150      }\n151  \n152      private String fooxx1_source(HttpServletRequest request, HttpServletResponse response) throws Throwable\n153      {\n154          String data = null;\n155  \n156          if (fooxx1_private)\n157          {\n158              \n159  \n160              data = null;\n161          }\n162          else\n163          {\n164  \n165              \n166              data = \"foo\";\n167  \n168          }\n169  \n170          return data;\n171      }\n172  \n173      \n174      private void fooxx2(HttpServletRequest request, HttpServletResponse response) throws Throwable\n175      {\n176          String data;\n177  \n178          fooxx2_private = true;\n179          data = fooxx2_source(request, response);\n180  \n181          if (data != null)\n182          {\n183              \n184              response.getWriter().println(\"<br>hoo(): data = \" + data.replaceAll(\"(<script>)\", \"\"));\n185          }\n186  \n187      }\n188  \n189      private String fooxx2_source(HttpServletRequest request, HttpServletResponse response) throws Throwable\n190      {\n191          String data = null;\n192  \n193          if (fooxx2_private)\n194          {\n195              \n196              data = \"foo\";\n197          }\n198          else\n199          {\n200              \n201  \n202              data = null;\n203          }\n204  \n205          return data;\n206      }\n207  \n208      \n209  \n210  \n211  \n212  \n213      public static void main(String[] args) throws ClassNotFoundException,\n214             InstantiationException, IllegalAccessException\n215      {\n216          mainFromParent(args);\n217      }\n218  \n219  }\n220  ",
    "trace_check_results": [
        {
            "trace": [
                [
                    44,
                    "data"
                ]
            ],
            "result": {
                "type_sanitize": 0,
                "functionality_sanitize": 0,
                "order_sanitize": 0,
                "reachability_sanitize": 0,
                "total": 1,
                "final": 0
            }
        },
        {
            "trace": [
                [
                    184,
                    "data"
                ]
            ],
            "result": {
                "type_sanitize": 0,
                "functionality_sanitize": 0,
                "order_sanitize": 0,
                "reachability_sanitize": 0,
                "total": 1,
                "final": 0
            }
        }
    ]
}