{
    "original code": "/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE80_XSS__CWE182_Servlet_connect_tcp_06.java\nLabel Definition File: CWE80_XSS__CWE182_Servlet.label.xml\nTemplate File: sources-sink-06.tmpl.java\n*/\n/*\n* @description\n* CWE: 80 Cross Site Scripting (XSS)\n* BadSource: connect_tcp Read data using an outbound tcp connection\n* GoodSource: A hardcoded string\n* BadSink:  Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS (CWE 182: Collapse of Data into Unsafe Value)\n* Flow Variant: 06 Control flow: if(PRIVATE_STATIC_FINAL_FIVE==5) and if(PRIVATE_STATIC_FINAL_FIVE!=5)\n*\n* */\n\npackage testcases.CWE80_XSS.s01;\nimport testcasesupport.*;\n\nimport javax.servlet.http.*;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.net.Socket;\n\nimport java.util.logging.Level;\n\npublic class CWE80_XSS__CWE182_Servlet_connect_tcp_06 extends AbstractTestCaseServlet\n{\n    /* The variable below is declared \"final\", so a tool should be able\n     * to identify that reads of this will always give its initialized\n     * value.\n     */\n    private static final int PRIVATE_STATIC_FINAL_FIVE = 5;\n\n    /* uses badsource and badsink */\n    public void bad(HttpServletRequest request, HttpServletResponse response) throws Throwable\n    {\n        String data;\n        if (PRIVATE_STATIC_FINAL_FIVE == 5)\n        {\n            data = \"\"; /* Initialize data */\n            /* Read data using an outbound tcp connection */\n            {\n                Socket socket = null;\n                BufferedReader readerBuffered = null;\n                InputStreamReader readerInputStream = null;\n                try\n                {\n                    /* Read data using an outbound tcp connection */\n                    socket = new Socket(\"host.example.org\", 39544);\n                    /* read input from socket */\n                    readerInputStream = new InputStreamReader(socket.getInputStream(), \"UTF-8\");\n                    readerBuffered = new BufferedReader(readerInputStream);\n                    /* POTENTIAL FLAW: Read data using an outbound tcp connection */\n                    data = readerBuffered.readLine();\n                }\n                catch (IOException exceptIO)\n                {\n                    IO.logger.log(Level.WARNING, \"Error with stream reading\", exceptIO);\n                }\n                finally\n                {\n                    /* clean up stream reading objects */\n                    try\n                    {\n                        if (readerBuffered != null)\n                        {\n                            readerBuffered.close();\n                        }\n                    }\n                    catch (IOException exceptIO)\n                    {\n                        IO.logger.log(Level.WARNING, \"Error closing BufferedReader\", exceptIO);\n                    }\n\n                    try\n                    {\n                        if (readerInputStream != null)\n                        {\n                            readerInputStream.close();\n                        }\n                    }\n                    catch (IOException exceptIO)\n                    {\n                        IO.logger.log(Level.WARNING, \"Error closing InputStreamReader\", exceptIO);\n                    }\n\n                    /* clean up socket objects */\n                    try\n                    {\n                        if (socket != null)\n                        {\n                            socket.close();\n                        }\n                    }\n                    catch (IOException exceptIO)\n                    {\n                        IO.logger.log(Level.WARNING, \"Error closing Socket\", exceptIO);\n                    }\n                }\n            }\n        }\n        else\n        {\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run\n             * but ensure data is inititialized before the Sink to avoid compiler errors */\n            data = null;\n        }\n\n        if (data != null)\n        {\n            /* POTENTIAL FLAW: Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS with strings like <scr<script>ipt> (CWE 182: Collapse of Data into Unsafe Value) */\n            response.getWriter().println(\"<br>bad(): data = \" + data.replaceAll(\"(<script>)\", \"\"));\n        }\n\n    }\n\n    /* goodG2B1() - use goodsource and badsink by changing PRIVATE_STATIC_FINAL_FIVE==5 to PRIVATE_STATIC_FINAL_FIVE!=5 */\n    private void goodG2B1(HttpServletRequest request, HttpServletResponse response) throws Throwable\n    {\n        String data;\n        if (PRIVATE_STATIC_FINAL_FIVE != 5)\n        {\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run\n             * but ensure data is inititialized before the Sink to avoid compiler errors */\n            data = null;\n        }\n        else\n        {\n\n            /* FIX: Use a hardcoded string */\n            data = \"foo\";\n\n        }\n\n        if (data != null)\n        {\n            /* POTENTIAL FLAW: Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS with strings like <scr<script>ipt> (CWE 182: Collapse of Data into Unsafe Value) */\n            response.getWriter().println(\"<br>bad(): data = \" + data.replaceAll(\"(<script>)\", \"\"));\n        }\n\n    }\n\n    /* goodG2B2() - use goodsource and badsink by reversing statements in if */\n    private void goodG2B2(HttpServletRequest request, HttpServletResponse response) throws Throwable\n    {\n        String data;\n        if (PRIVATE_STATIC_FINAL_FIVE == 5)\n        {\n            /* FIX: Use a hardcoded string */\n            data = \"foo\";\n        }\n        else\n        {\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run\n             * but ensure data is inititialized before the Sink to avoid compiler errors */\n            data = null;\n        }\n\n        if (data != null)\n        {\n            /* POTENTIAL FLAW: Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS with strings like <scr<script>ipt> (CWE 182: Collapse of Data into Unsafe Value) */\n            response.getWriter().println(\"<br>bad(): data = \" + data.replaceAll(\"(<script>)\", \"\"));\n        }\n\n    }\n\n    public void good(HttpServletRequest request, HttpServletResponse response) throws Throwable\n    {\n        goodG2B1(request, response);\n        goodG2B2(request, response);\n    }\n\n    /* Below is the main(). It is only used when building this testcase on\n     * its own for testing or for building a binary to use in testing binary\n     * analysis tools. It is not used when compiling all the testcases as one\n     * application, which is how source code analysis tools are tested.\n     */\n    public static void main(String[] args) throws ClassNotFoundException,\n           InstantiationException, IllegalAccessException\n    {\n        mainFromParent(args);\n    }\n}\n",
    "analyzed code": "1  \n2  \n3  \n4  \n5  \n6  \n7  \n8  \n9  \n10  \n11  \n12  \n13  \n14  \n15  \n16  package testcases.CWE80_XSS.s01;\n17  import testcasesupport.*;\n18  \n19  import javax.servlet.http.*;\n20  \n21  import java.io.BufferedReader;\n22  import java.io.InputStreamReader;\n23  import java.io.IOException;\n24  import java.net.Socket;\n25  \n26  import java.util.logging.Level;\n27  \n28  public class CWE80_XSS__CWE182_Servlet_connect_tcp_06 extends AbstractTestCaseServlet\n29  {\n30      \n31  \n32  \n33  \n34      private static final int PRIVATE_STATIC_FINAL_FIVE = 5;\n35  \n36      \n37      public void hoo(HttpServletRequest request, HttpServletResponse response) throws Throwable\n38      {\n39          String data;\n40          if (PRIVATE_STATIC_FINAL_FIVE == 5)\n41          {\n42              data = \"\"; \n43              \n44              {\n45                  Socket socket = null;\n46                  BufferedReader readerBuffered = null;\n47                  InputStreamReader readerInputStream = null;\n48                  try\n49                  {\n50                      \n51                      socket = new Socket(\"host.example.org\", 39544);\n52                      \n53                      readerInputStream = new InputStreamReader(socket.getInputStream(), \"UTF-8\");\n54                      readerBuffered = new BufferedReader(readerInputStream);\n55                      \n56                      data = readerBuffered.readLine();\n57                  }\n58                  catch (IOException exceptIO)\n59                  {\n60                      IO.logger.log(Level.WARNING, \"Error with stream reading\", exceptIO);\n61                  }\n62                  finally\n63                  {\n64                      \n65                      try\n66                      {\n67                          if (readerBuffered != null)\n68                          {\n69                              readerBuffered.close();\n70                          }\n71                      }\n72                      catch (IOException exceptIO)\n73                      {\n74                          IO.logger.log(Level.WARNING, \"Error closing BufferedReader\", exceptIO);\n75                      }\n76  \n77                      try\n78                      {\n79                          if (readerInputStream != null)\n80                          {\n81                              readerInputStream.close();\n82                          }\n83                      }\n84                      catch (IOException exceptIO)\n85                      {\n86                          IO.logger.log(Level.WARNING, \"Error closing InputStreamReader\", exceptIO);\n87                      }\n88  \n89                      \n90                      try\n91                      {\n92                          if (socket != null)\n93                          {\n94                              socket.close();\n95                          }\n96                      }\n97                      catch (IOException exceptIO)\n98                      {\n99                          IO.logger.log(Level.WARNING, \"Error closing Socket\", exceptIO);\n100                      }\n101                  }\n102              }\n103          }\n104          else\n105          {\n106              \n107  \n108              data = null;\n109          }\n110  \n111          if (data != null)\n112          {\n113              \n114              response.getWriter().println(\"<br>hoo(): data = \" + data.replaceAll(\"(<script>)\", \"\"));\n115          }\n116  \n117      }\n118  \n119      \n120      private void fooxx1(HttpServletRequest request, HttpServletResponse response) throws Throwable\n121      {\n122          String data;\n123          if (PRIVATE_STATIC_FINAL_FIVE != 5)\n124          {\n125              \n126  \n127              data = null;\n128          }\n129          else\n130          {\n131  \n132              \n133              data = \"foo\";\n134  \n135          }\n136  \n137          if (data != null)\n138          {\n139              \n140              response.getWriter().println(\"<br>hoo(): data = \" + data.replaceAll(\"(<script>)\", \"\"));\n141          }\n142  \n143      }\n144  \n145      \n146      private void fooxx2(HttpServletRequest request, HttpServletResponse response) throws Throwable\n147      {\n148          String data;\n149          if (PRIVATE_STATIC_FINAL_FIVE == 5)\n150          {\n151              \n152              data = \"foo\";\n153          }\n154          else\n155          {\n156              \n157  \n158              data = null;\n159          }\n160  \n161          if (data != null)\n162          {\n163              \n164              response.getWriter().println(\"<br>hoo(): data = \" + data.replaceAll(\"(<script>)\", \"\"));\n165          }\n166  \n167      }\n168  \n169      public void foo(HttpServletRequest request, HttpServletResponse response) throws Throwable\n170      {\n171          fooxx1(request, response);\n172          fooxx2(request, response);\n173      }\n174  \n175      \n176  \n177  \n178  \n179  \n180      public static void main(String[] args) throws ClassNotFoundException,\n181             InstantiationException, IllegalAccessException\n182      {\n183          mainFromParent(args);\n184      }\n185  }\n186  ",
    "trace_check_results": [
        {
            "trace": [
                [
                    56,
                    "data"
                ],
                [
                    114,
                    "data.replaceAll(\"(<script>)\", \"\")"
                ]
            ],
            "result": {
                "type_sanitize": 1,
                "functionality_sanitize": 1,
                "order_sanitize": 1,
                "reachability_sanitize": 1,
                "total": 1,
                "final": 1
            }
        }
    ]
}