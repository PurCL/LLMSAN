{
    "original code": "/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE476_NULL_Pointer_Dereference__StringBuilder_08.java\nLabel Definition File: CWE476_NULL_Pointer_Dereference.label.xml\nTemplate File: sources-sinks-08.tmpl.java\n*/\n/*\n* @description\n* CWE: 476 Null Pointer Dereference\n* BadSource:  Set data to null\n* GoodSource: Set data to a non-null value\n* Sinks:\n*    GoodSink: add check to prevent possibility of null dereference\n*    BadSink : possibility of null dereference\n* Flow Variant: 08 Control flow: if(privateReturnsTrue()) and if(privateReturnsFalse())\n*\n* */\n\npackage testcases.CWE476_NULL_Pointer_Dereference;\n\nimport testcasesupport.*;\n\npublic class CWE476_NULL_Pointer_Dereference__StringBuilder_08 extends AbstractTestCase\n{\n    /* The methods below always return the same value, so a tool\n     * should be able to figure out that every call to these\n     * methods will return true or return false. */\n    private boolean privateReturnsTrue()\n    {\n        return true;\n    }\n\n    private boolean privateReturnsFalse()\n    {\n        return false;\n    }\n\n    public void bad() throws Throwable\n    {\n        StringBuilder data;\n        if (privateReturnsTrue())\n        {\n            /* POTENTIAL FLAW: data is null */\n            data = null;\n        }\n        else\n        {\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run\n             * but ensure data is initialized before the Sink to avoid compiler errors */\n            data = null;\n        }\n\n        if (privateReturnsTrue())\n        {\n            /* POTENTIAL FLAW: null dereference will occur if data is null */\n            IO.writeLine(\"\" + data.length());\n        }\n    }\n\n    private void goodG2B1() throws Throwable\n    {\n        StringBuilder data;\n        if (privateReturnsFalse())\n        {\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run\n             * but ensure data is initialized before the Sink to avoid compiler errors */\n            data = null;\n        }\n        else\n        {\n\n            /* FIX: hardcode data to non-null */\n            data = new StringBuilder();\n\n        }\n\n        if (privateReturnsTrue())\n        {\n            /* POTENTIAL FLAW: null dereference will occur if data is null */\n            IO.writeLine(\"\" + data.length());\n        }\n    }\n\n    /* goodG2B2() - use goodsource and badsink by reversing statements in first if */\n    private void goodG2B2() throws Throwable\n    {\n        StringBuilder data;\n        if (privateReturnsTrue())\n        {\n            /* FIX: hardcode data to non-null */\n            data = new StringBuilder();\n        }\n        else\n        {\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run\n             * but ensure data is inititialized before the Sink to avoid compiler errors */\n            data = null;\n        }\n\n        if (privateReturnsTrue())\n        {\n            /* POTENTIAL FLAW: null dereference will occur if data is null */\n            IO.writeLine(\"\" + data.length());\n        }\n    }\n\n    /* goodB2G1() - use badsource and goodsink by changing second privateReturnsTrue() to privateReturnsFalse() */\n    private void goodB2G1() throws Throwable\n    {\n        StringBuilder data;\n        if (privateReturnsTrue())\n        {\n            /* POTENTIAL FLAW: data is null */\n            data = null;\n        }\n        else\n        {\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run\n             * but ensure data is inititialized before the Sink to avoid compiler errors */\n            data = null;\n        }\n\n        if (privateReturnsFalse())\n        {\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n            IO.writeLine(\"Benign, fixed string\");\n        }\n        else\n        {\n\n            /* FIX: validate that data is non-null */\n            if (data != null)\n            {\n                IO.writeLine(\"\" + data.length());\n            }\n            else\n            {\n                IO.writeLine(\"data is null\");\n            }\n\n        }\n    }\n\n    /* goodB2G2() - use badsource and goodsink by reversing statements in second if  */\n    private void goodB2G2() throws Throwable\n    {\n        StringBuilder data;\n        if (privateReturnsTrue())\n        {\n            /* POTENTIAL FLAW: data is null */\n            data = null;\n        }\n        else\n        {\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run\n             * but ensure data is inititialized before the Sink to avoid compiler errors */\n            data = null;\n        }\n\n        if (privateReturnsTrue())\n        {\n            /* FIX: validate that data is non-null */\n            if (data != null)\n            {\n                IO.writeLine(\"\" + data.length());\n            }\n            else\n            {\n                IO.writeLine(\"data is null\");\n            }\n        }\n    }\n\n    public void good() throws Throwable\n    {\n        goodG2B1();\n        goodG2B2();\n        goodB2G1();\n        goodB2G2();\n    }\n\n    /* Below is the main(). It is only used when building this testcase on\n     * its own for testing or for building a binary to use in testing binary\n     * analysis tools. It is not used when compiling all the testcases as one\n     * application, which is how source code analysis tools are tested.\n     */\n    public static void main(String[] args) throws ClassNotFoundException,\n           InstantiationException, IllegalAccessException\n    {\n        mainFromParent(args);\n    }\n}\n",
    "analyzed code": "1  \n2  \n3  \n4  \n5  \n6  \n7  \n8  \n9  \n10  \n11  \n12  \n13  \n14  \n15  \n16  \n17  \n18  package testcases.CWE476_NULL_Pointer_Dereference;\n19  \n20  import testcasesupport.*;\n21  \n22  public class CWE476_NULL_Pointer_Dereference__StringBuilder_08 extends AbstractTestCase\n23  {\n24      \n25  \n26  \n27      private boolean privateReturnsTrue()\n28      {\n29          return true;\n30      }\n31  \n32      private boolean privateReturnsFalse()\n33      {\n34          return false;\n35      }\n36  \n37      public void hoo() throws Throwable\n38      {\n39          StringBuilder data;\n40          if (privateReturnsTrue())\n41          {\n42              \n43              data = null;\n44          }\n45          else\n46          {\n47              \n48  \n49              data = null;\n50          }\n51  \n52          if (privateReturnsTrue())\n53          {\n54              \n55              IO.writeLine(\"\" + data.length());\n56          }\n57      }\n58  \n59      private void fooxx1() throws Throwable\n60      {\n61          StringBuilder data;\n62          if (privateReturnsFalse())\n63          {\n64              \n65  \n66              data = null;\n67          }\n68          else\n69          {\n70  \n71              \n72              data = new StringBuilder();\n73  \n74          }\n75  \n76          if (privateReturnsTrue())\n77          {\n78              \n79              IO.writeLine(\"\" + data.length());\n80          }\n81      }\n82  \n83      \n84      private void fooxx2() throws Throwable\n85      {\n86          StringBuilder data;\n87          if (privateReturnsTrue())\n88          {\n89              \n90              data = new StringBuilder();\n91          }\n92          else\n93          {\n94              \n95  \n96              data = null;\n97          }\n98  \n99          if (privateReturnsTrue())\n100          {\n101              \n102              IO.writeLine(\"\" + data.length());\n103          }\n104      }\n105  \n106      \n107      private void fooyy1() throws Throwable\n108      {\n109          StringBuilder data;\n110          if (privateReturnsTrue())\n111          {\n112              \n113              data = null;\n114          }\n115          else\n116          {\n117              \n118  \n119              data = null;\n120          }\n121  \n122          if (privateReturnsFalse())\n123          {\n124              \n125              IO.writeLine(\"Benign, fixed string\");\n126          }\n127          else\n128          {\n129  \n130              \n131              if (data != null)\n132              {\n133                  IO.writeLine(\"\" + data.length());\n134              }\n135              else\n136              {\n137                  IO.writeLine(\"data is null\");\n138              }\n139  \n140          }\n141      }\n142  \n143      \n144      private void fooyy2() throws Throwable\n145      {\n146          StringBuilder data;\n147          if (privateReturnsTrue())\n148          {\n149              \n150              data = null;\n151          }\n152          else\n153          {\n154              \n155  \n156              data = null;\n157          }\n158  \n159          if (privateReturnsTrue())\n160          {\n161              \n162              if (data != null)\n163              {\n164                  IO.writeLine(\"\" + data.length());\n165              }\n166              else\n167              {\n168                  IO.writeLine(\"data is null\");\n169              }\n170          }\n171      }\n172  \n173      public void foo() throws Throwable\n174      {\n175          fooxx1();\n176          fooxx2();\n177          fooyy1();\n178          fooyy2();\n179      }\n180  \n181      \n182  \n183  \n184  \n185  \n186      public static void main(String[] args) throws ClassNotFoundException,\n187             InstantiationException, IllegalAccessException\n188      {\n189          mainFromParent(args);\n190      }\n191  }\n192  ",
    "trace_check_results": [
        {
            "trace": [
                [
                    39,
                    "data"
                ],
                [
                    55,
                    "data"
                ]
            ],
            "result": {
                "type_sanitize": 0,
                "functionality_sanitize": 1,
                "order_sanitize": 1,
                "reachability_sanitize": 0,
                "total": 1,
                "final": 0
            }
        },
        {
            "trace": [
                [
                    61,
                    "data"
                ],
                [
                    79,
                    "data"
                ]
            ],
            "result": {
                "type_sanitize": 0,
                "functionality_sanitize": 1,
                "order_sanitize": 1,
                "reachability_sanitize": 0,
                "total": 1,
                "final": 0
            }
        },
        {
            "trace": [
                [
                    96,
                    "data"
                ],
                [
                    102,
                    "data"
                ]
            ],
            "result": {
                "type_sanitize": 1,
                "functionality_sanitize": 1,
                "order_sanitize": 1,
                "reachability_sanitize": 0,
                "total": 1,
                "final": 0
            }
        },
        {
            "trace": [
                [
                    150,
                    "data"
                ],
                [
                    164,
                    "data"
                ]
            ],
            "result": {
                "type_sanitize": 1,
                "functionality_sanitize": 0,
                "order_sanitize": 1,
                "reachability_sanitize": 1,
                "total": 1,
                "final": 0
            }
        }
    ]
}