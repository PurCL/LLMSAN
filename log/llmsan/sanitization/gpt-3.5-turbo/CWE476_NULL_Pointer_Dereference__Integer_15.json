{
    "original code": "/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE476_NULL_Pointer_Dereference__Integer_15.java\nLabel Definition File: CWE476_NULL_Pointer_Dereference.label.xml\nTemplate File: sources-sinks-15.tmpl.java\n*/\n/*\n* @description\n* CWE: 476 Null Pointer Dereference\n* BadSource:  Set data to null\n* GoodSource: Set data to a non-null value\n* Sinks:\n*    GoodSink: add check to prevent possibility of null dereference\n*    BadSink : possibility of null dereference\n* Flow Variant: 15 Control flow: switch(6) and switch(7)\n*\n* */\n\npackage testcases.CWE476_NULL_Pointer_Dereference;\n\nimport testcasesupport.*;\n\npublic class CWE476_NULL_Pointer_Dereference__Integer_15 extends AbstractTestCase\n{\n    public void bad() throws Throwable\n    {\n        Integer data;\n\n        switch (6)\n        {\n        case 6:\n            /* POTENTIAL FLAW: data is null */\n            data = null;\n            break;\n        default:\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run\n             * but ensure data is inititialized before the Sink to avoid compiler errors */\n            data = null;\n            break;\n        }\n\n        switch (7)\n        {\n        case 7:\n            /* POTENTIAL FLAW: null dereference will occur if data is null */\n            IO.writeLine(\"\" + data.toString());\n            break;\n        default:\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n            IO.writeLine(\"Benign, fixed string\");\n            break;\n        }\n    }\n\n    /* goodG2B1() - use goodsource and badsink by changing the first switch to switch(5) */\n    private void goodG2B1() throws Throwable\n    {\n        Integer data;\n\n        switch (5)\n        {\n        case 6:\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run\n             * but ensure data is inititialized before the Sink to avoid compiler errors */\n            data = null;\n            break;\n        default:\n            /* FIX: hardcode data to non-null */\n            data = Integer.valueOf(5);\n            break;\n        }\n\n        switch (7)\n        {\n        case 7:\n            /* POTENTIAL FLAW: null dereference will occur if data is null */\n            IO.writeLine(\"\" + data.toString());\n            break;\n        default:\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n            IO.writeLine(\"Benign, fixed string\");\n            break;\n        }\n    }\n\n    /* goodG2B2() - use goodsource and badsink by reversing the blocks in the first switch  */\n    private void goodG2B2() throws Throwable\n    {\n        Integer data;\n\n        switch (6)\n        {\n        case 6:\n            /* FIX: hardcode data to non-null */\n            data = Integer.valueOf(5);\n            break;\n        default:\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run\n             * but ensure data is inititialized before the Sink to avoid compiler errors */\n            data = null;\n            break;\n        }\n\n        switch (7)\n        {\n        case 7:\n            /* POTENTIAL FLAW: null dereference will occur if data is null */\n            IO.writeLine(\"\" + data.toString());\n            break;\n        default:\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n            IO.writeLine(\"Benign, fixed string\");\n            break;\n        }\n    }\n\n    /* goodB2G1() - use badsource and goodsink by changing the second switch to switch(8) */\n    private void goodB2G1() throws Throwable\n    {\n        Integer data;\n\n        switch (6)\n        {\n        case 6:\n            /* POTENTIAL FLAW: data is null */\n            data = null;\n            break;\n        default:\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run\n             * but ensure data is inititialized before the Sink to avoid compiler errors */\n            data = null;\n            break;\n        }\n\n        switch (8)\n        {\n        case 7:\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n            IO.writeLine(\"Benign, fixed string\");\n            break;\n        default:\n            /* FIX: validate that data is non-null */\n            if (data != null)\n            {\n                IO.writeLine(\"\" + data.toString());\n            }\n            else\n            {\n                IO.writeLine(\"data is null\");\n            }\n            break;\n        }\n    }\n\n    /* goodB2G2() - use badsource and goodsink by reversing the blocks in the second switch  */\n    private void goodB2G2() throws Throwable\n    {\n        Integer data;\n\n        switch (6)\n        {\n        case 6:\n            /* POTENTIAL FLAW: data is null */\n            data = null;\n            break;\n        default:\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run\n             * but ensure data is inititialized before the Sink to avoid compiler errors */\n            data = null;\n            break;\n        }\n\n        switch (7)\n        {\n        case 7:\n            /* FIX: validate that data is non-null */\n            if (data != null)\n            {\n                IO.writeLine(\"\" + data.toString());\n            }\n            else\n            {\n                IO.writeLine(\"data is null\");\n            }\n            break;\n        default:\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n            IO.writeLine(\"Benign, fixed string\");\n            break;\n        }\n    }\n\n    public void good() throws Throwable\n    {\n        goodG2B1();\n        goodG2B2();\n        goodB2G1();\n        goodB2G2();\n    }\n\n    /* Below is the main(). It is only used when building this testcase on\n     * its own for testing or for building a binary to use in testing binary\n     * analysis tools. It is not used when compiling all the testcases as one\n     * application, which is how source code analysis tools are tested.\n     */\n    public static void main(String[] args) throws ClassNotFoundException,\n           InstantiationException, IllegalAccessException\n    {\n        mainFromParent(args);\n    }\n}\n",
    "analyzed code": "1  \n2  \n3  \n4  \n5  \n6  \n7  \n8  \n9  \n10  \n11  \n12  \n13  \n14  \n15  \n16  \n17  \n18  package testcases.CWE476_NULL_Pointer_Dereference;\n19  \n20  import testcasesupport.*;\n21  \n22  public class CWE476_NULL_Pointer_Dereference__Integer_15 extends AbstractTestCase\n23  {\n24      public void hoo() throws Throwable\n25      {\n26          Integer data;\n27  \n28          switch (6)\n29          {\n30          case 6:\n31              \n32              data = null;\n33              break;\n34          default:\n35              \n36  \n37              data = null;\n38              break;\n39          }\n40  \n41          switch (7)\n42          {\n43          case 7:\n44              \n45              IO.writeLine(\"\" + data.toString());\n46              break;\n47          default:\n48              \n49              IO.writeLine(\"Benign, fixed string\");\n50              break;\n51          }\n52      }\n53  \n54      \n55      private void fooxx1() throws Throwable\n56      {\n57          Integer data;\n58  \n59          switch (5)\n60          {\n61          case 6:\n62              \n63  \n64              data = null;\n65              break;\n66          default:\n67              \n68              data = Integer.valueOf(5);\n69              break;\n70          }\n71  \n72          switch (7)\n73          {\n74          case 7:\n75              \n76              IO.writeLine(\"\" + data.toString());\n77              break;\n78          default:\n79              \n80              IO.writeLine(\"Benign, fixed string\");\n81              break;\n82          }\n83      }\n84  \n85      \n86      private void fooxx2() throws Throwable\n87      {\n88          Integer data;\n89  \n90          switch (6)\n91          {\n92          case 6:\n93              \n94              data = Integer.valueOf(5);\n95              break;\n96          default:\n97              \n98  \n99              data = null;\n100              break;\n101          }\n102  \n103          switch (7)\n104          {\n105          case 7:\n106              \n107              IO.writeLine(\"\" + data.toString());\n108              break;\n109          default:\n110              \n111              IO.writeLine(\"Benign, fixed string\");\n112              break;\n113          }\n114      }\n115  \n116      \n117      private void fooyy1() throws Throwable\n118      {\n119          Integer data;\n120  \n121          switch (6)\n122          {\n123          case 6:\n124              \n125              data = null;\n126              break;\n127          default:\n128              \n129  \n130              data = null;\n131              break;\n132          }\n133  \n134          switch (8)\n135          {\n136          case 7:\n137              \n138              IO.writeLine(\"Benign, fixed string\");\n139              break;\n140          default:\n141              \n142              if (data != null)\n143              {\n144                  IO.writeLine(\"\" + data.toString());\n145              }\n146              else\n147              {\n148                  IO.writeLine(\"data is null\");\n149              }\n150              break;\n151          }\n152      }\n153  \n154      \n155      private void fooyy2() throws Throwable\n156      {\n157          Integer data;\n158  \n159          switch (6)\n160          {\n161          case 6:\n162              \n163              data = null;\n164              break;\n165          default:\n166              \n167  \n168              data = null;\n169              break;\n170          }\n171  \n172          switch (7)\n173          {\n174          case 7:\n175              \n176              if (data != null)\n177              {\n178                  IO.writeLine(\"\" + data.toString());\n179              }\n180              else\n181              {\n182                  IO.writeLine(\"data is null\");\n183              }\n184              break;\n185          default:\n186              \n187              IO.writeLine(\"Benign, fixed string\");\n188              break;\n189          }\n190      }\n191  \n192      public void foo() throws Throwable\n193      {\n194          fooxx1();\n195          fooxx2();\n196          fooyy1();\n197          fooyy2();\n198      }\n199  \n200      \n201  \n202  \n203  \n204  \n205      public static void main(String[] args) throws ClassNotFoundException,\n206             InstantiationException, IllegalAccessException\n207      {\n208          mainFromParent(args);\n209      }\n210  }\n211  ",
    "trace_check_results": [
        {
            "trace": [
                [
                    32,
                    "data"
                ],
                [
                    45,
                    "data"
                ]
            ],
            "result": {
                "type_sanitize": 1,
                "functionality_sanitize": 1,
                "order_sanitize": 1,
                "reachability_sanitize": 1,
                "total": 1,
                "final": 1
            }
        },
        {
            "trace": [
                [
                    64,
                    "data"
                ],
                [
                    76,
                    "data"
                ]
            ],
            "result": {
                "type_sanitize": 1,
                "functionality_sanitize": 0,
                "order_sanitize": 1,
                "reachability_sanitize": 0,
                "total": 1,
                "final": 0
            }
        },
        {
            "trace": [
                [
                    99,
                    "data"
                ],
                [
                    107,
                    "data"
                ]
            ],
            "result": {
                "type_sanitize": 1,
                "functionality_sanitize": 0,
                "order_sanitize": 1,
                "reachability_sanitize": 0,
                "total": 1,
                "final": 0
            }
        },
        {
            "trace": [
                [
                    125,
                    "data"
                ],
                [
                    144,
                    "data"
                ]
            ],
            "result": {
                "type_sanitize": 1,
                "functionality_sanitize": 1,
                "order_sanitize": 1,
                "reachability_sanitize": 1,
                "total": 1,
                "final": 1
            }
        }
    ]
}