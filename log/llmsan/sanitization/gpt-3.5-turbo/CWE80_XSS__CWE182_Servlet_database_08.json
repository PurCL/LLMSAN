{
    "original code": "/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE80_XSS__CWE182_Servlet_database_08.java\nLabel Definition File: CWE80_XSS__CWE182_Servlet.label.xml\nTemplate File: sources-sink-08.tmpl.java\n*/\n/*\n* @description\n* CWE: 80 Cross Site Scripting (XSS)\n* BadSource: database Read data from a database\n* GoodSource: A hardcoded string\n* BadSink:  Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS (CWE 182: Collapse of Data into Unsafe Value)\n* Flow Variant: 08 Control flow: if(privateReturnsTrue()) and if(privateReturnsFalse())\n*\n* */\n\npackage testcases.CWE80_XSS.s01;\nimport testcasesupport.*;\n\nimport javax.servlet.http.*;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\nimport java.util.logging.Level;\n\npublic class CWE80_XSS__CWE182_Servlet_database_08 extends AbstractTestCaseServlet\n{\n    /* The methods below always return the same value, so a tool\n     * should be able to figure out that every call to these\n     * methods will return true or return false.\n     */\n    private boolean privateReturnsTrue()\n    {\n        return true;\n    }\n\n    private boolean privateReturnsFalse()\n    {\n        return false;\n    }\n\n    /* uses badsource and badsink */\n    public void bad(HttpServletRequest request, HttpServletResponse response) throws Throwable\n    {\n        String data;\n        if (privateReturnsTrue())\n        {\n            data = \"\"; /* Initialize data */\n            /* Read data from a database */\n            {\n                Connection connection = null;\n                PreparedStatement preparedStatement = null;\n                ResultSet resultSet = null;\n                try\n                {\n                    /* setup the connection */\n                    connection = IO.getDBConnection();\n                    /* prepare and execute a (hardcoded) query */\n                    preparedStatement = connection.prepareStatement(\"select name from users where id=0\");\n                    resultSet = preparedStatement.executeQuery();\n                    /* POTENTIAL FLAW: Read data from a database query resultset */\n                    data = resultSet.getString(1);\n                }\n                catch (SQLException exceptSql)\n                {\n                    IO.logger.log(Level.WARNING, \"Error with SQL statement\", exceptSql);\n                }\n                finally\n                {\n                    /* Close database objects */\n                    try\n                    {\n                        if (resultSet != null)\n                        {\n                            resultSet.close();\n                        }\n                    }\n                    catch (SQLException exceptSql)\n                    {\n                        IO.logger.log(Level.WARNING, \"Error closing ResultSet\", exceptSql);\n                    }\n\n                    try\n                    {\n                        if (preparedStatement != null)\n                        {\n                            preparedStatement.close();\n                        }\n                    }\n                    catch (SQLException exceptSql)\n                    {\n                        IO.logger.log(Level.WARNING, \"Error closing PreparedStatement\", exceptSql);\n                    }\n\n                    try\n                    {\n                        if (connection != null)\n                        {\n                            connection.close();\n                        }\n                    }\n                    catch (SQLException exceptSql)\n                    {\n                        IO.logger.log(Level.WARNING, \"Error closing Connection\", exceptSql);\n                    }\n                }\n            }\n        }\n        else\n        {\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run\n             * but ensure data is inititialized before the Sink to avoid compiler errors */\n            data = null;\n        }\n\n        if (data != null)\n        {\n            /* POTENTIAL FLAW: Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS with strings like <scr<script>ipt> (CWE 182: Collapse of Data into Unsafe Value) */\n            response.getWriter().println(\"<br>bad(): data = \" + data.replaceAll(\"(<script>)\", \"\"));\n        }\n\n    }\n\n    /* goodG2B1() - use goodsource and badsink by changing privateReturnsTrue() to privateReturnsFalse() */\n    private void goodG2B1(HttpServletRequest request, HttpServletResponse response) throws Throwable\n    {\n        String data;\n        if (privateReturnsFalse())\n        {\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run\n             * but ensure data is inititialized before the Sink to avoid compiler errors */\n            data = null;\n        }\n        else\n        {\n\n            /* FIX: Use a hardcoded string */\n            data = \"foo\";\n\n        }\n\n        if (data != null)\n        {\n            /* POTENTIAL FLAW: Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS with strings like <scr<script>ipt> (CWE 182: Collapse of Data into Unsafe Value) */\n            response.getWriter().println(\"<br>bad(): data = \" + data.replaceAll(\"(<script>)\", \"\"));\n        }\n\n    }\n\n    /* goodG2B2() - use goodsource and badsink by reversing statements in if */\n    private void goodG2B2(HttpServletRequest request, HttpServletResponse response) throws Throwable\n    {\n        String data;\n        if (privateReturnsTrue())\n        {\n            /* FIX: Use a hardcoded string */\n            data = \"foo\";\n        }\n        else\n        {\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run\n             * but ensure data is inititialized before the Sink to avoid compiler errors */\n            data = null;\n        }\n\n        if (data != null)\n        {\n            /* POTENTIAL FLAW: Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS with strings like <scr<script>ipt> (CWE 182: Collapse of Data into Unsafe Value) */\n            response.getWriter().println(\"<br>bad(): data = \" + data.replaceAll(\"(<script>)\", \"\"));\n        }\n\n    }\n\n    public void good(HttpServletRequest request, HttpServletResponse response) throws Throwable\n    {\n        goodG2B1(request, response);\n        goodG2B2(request, response);\n    }\n\n    /* Below is the main(). It is only used when building this testcase on\n     * its own for testing or for building a binary to use in testing binary\n     * analysis tools. It is not used when compiling all the testcases as one\n     * application, which is how source code analysis tools are tested.\n     */\n    public static void main(String[] args) throws ClassNotFoundException,\n           InstantiationException, IllegalAccessException\n    {\n        mainFromParent(args);\n    }\n}\n",
    "analyzed code": "1  \n2  \n3  \n4  \n5  \n6  \n7  \n8  \n9  \n10  \n11  \n12  \n13  \n14  \n15  \n16  package testcases.CWE80_XSS.s01;\n17  import testcasesupport.*;\n18  \n19  import javax.servlet.http.*;\n20  \n21  import java.sql.Connection;\n22  import java.sql.PreparedStatement;\n23  import java.sql.ResultSet;\n24  import java.sql.SQLException;\n25  \n26  import java.util.logging.Level;\n27  \n28  public class CWE80_XSS__CWE182_Servlet_database_08 extends AbstractTestCaseServlet\n29  {\n30      \n31  \n32  \n33  \n34      private boolean privateReturnsTrue()\n35      {\n36          return true;\n37      }\n38  \n39      private boolean privateReturnsFalse()\n40      {\n41          return false;\n42      }\n43  \n44      \n45      public void hoo(HttpServletRequest request, HttpServletResponse response) throws Throwable\n46      {\n47          String data;\n48          if (privateReturnsTrue())\n49          {\n50              data = \"\"; \n51              \n52              {\n53                  Connection connection = null;\n54                  PreparedStatement preparedStatement = null;\n55                  ResultSet resultSet = null;\n56                  try\n57                  {\n58                      \n59                      connection = IO.getDBConnection();\n60                      \n61                      preparedStatement = connection.prepareStatement(\"select name from users where id=0\");\n62                      resultSet = preparedStatement.executeQuery();\n63                      \n64                      data = resultSet.getString(1);\n65                  }\n66                  catch (SQLException exceptSql)\n67                  {\n68                      IO.logger.log(Level.WARNING, \"Error with SQL statement\", exceptSql);\n69                  }\n70                  finally\n71                  {\n72                      \n73                      try\n74                      {\n75                          if (resultSet != null)\n76                          {\n77                              resultSet.close();\n78                          }\n79                      }\n80                      catch (SQLException exceptSql)\n81                      {\n82                          IO.logger.log(Level.WARNING, \"Error closing ResultSet\", exceptSql);\n83                      }\n84  \n85                      try\n86                      {\n87                          if (preparedStatement != null)\n88                          {\n89                              preparedStatement.close();\n90                          }\n91                      }\n92                      catch (SQLException exceptSql)\n93                      {\n94                          IO.logger.log(Level.WARNING, \"Error closing PreparedStatement\", exceptSql);\n95                      }\n96  \n97                      try\n98                      {\n99                          if (connection != null)\n100                          {\n101                              connection.close();\n102                          }\n103                      }\n104                      catch (SQLException exceptSql)\n105                      {\n106                          IO.logger.log(Level.WARNING, \"Error closing Connection\", exceptSql);\n107                      }\n108                  }\n109              }\n110          }\n111          else\n112          {\n113              \n114  \n115              data = null;\n116          }\n117  \n118          if (data != null)\n119          {\n120              \n121              response.getWriter().println(\"<br>hoo(): data = \" + data.replaceAll(\"(<script>)\", \"\"));\n122          }\n123  \n124      }\n125  \n126      \n127      private void fooxx1(HttpServletRequest request, HttpServletResponse response) throws Throwable\n128      {\n129          String data;\n130          if (privateReturnsFalse())\n131          {\n132              \n133  \n134              data = null;\n135          }\n136          else\n137          {\n138  \n139              \n140              data = \"foo\";\n141  \n142          }\n143  \n144          if (data != null)\n145          {\n146              \n147              response.getWriter().println(\"<br>hoo(): data = \" + data.replaceAll(\"(<script>)\", \"\"));\n148          }\n149  \n150      }\n151  \n152      \n153      private void fooxx2(HttpServletRequest request, HttpServletResponse response) throws Throwable\n154      {\n155          String data;\n156          if (privateReturnsTrue())\n157          {\n158              \n159              data = \"foo\";\n160          }\n161          else\n162          {\n163              \n164  \n165              data = null;\n166          }\n167  \n168          if (data != null)\n169          {\n170              \n171              response.getWriter().println(\"<br>hoo(): data = \" + data.replaceAll(\"(<script>)\", \"\"));\n172          }\n173  \n174      }\n175  \n176      public void foo(HttpServletRequest request, HttpServletResponse response) throws Throwable\n177      {\n178          fooxx1(request, response);\n179          fooxx2(request, response);\n180      }\n181  \n182      \n183  \n184  \n185  \n186  \n187      public static void main(String[] args) throws ClassNotFoundException,\n188             InstantiationException, IllegalAccessException\n189      {\n190          mainFromParent(args);\n191      }\n192  }\n193  ",
    "trace_check_results": [
        {
            "trace": [
                [
                    64,
                    "data"
                ],
                [
                    121,
                    "data.replaceAll(\"(<script>)\", \"\")"
                ]
            ],
            "result": {
                "type_sanitize": 1,
                "functionality_sanitize": 1,
                "order_sanitize": 1,
                "reachability_sanitize": 1,
                "total": 1,
                "final": 1
            }
        }
    ]
}