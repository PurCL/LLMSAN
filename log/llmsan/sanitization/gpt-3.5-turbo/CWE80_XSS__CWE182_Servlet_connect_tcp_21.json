{
    "original code": "/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE80_XSS__CWE182_Servlet_connect_tcp_21.java\nLabel Definition File: CWE80_XSS__CWE182_Servlet.label.xml\nTemplate File: sources-sink-21.tmpl.java\n*/\n/*\n * @description\n * CWE: 80 Cross Site Scripting (XSS)\n * BadSource: connect_tcp Read data using an outbound tcp connection\n * GoodSource: A hardcoded string\n * Sinks:\n *    BadSink : Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS (CWE 182: Collapse of Data into Unsafe Value)\n * Flow Variant: 21 Control flow: Flow controlled by value of a private variable. All functions contained in one file.\n *\n * */\n\npackage testcases.CWE80_XSS.s01;\nimport testcasesupport.*;\n\nimport javax.servlet.http.*;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.net.Socket;\n\nimport java.util.logging.Level;\n\npublic class CWE80_XSS__CWE182_Servlet_connect_tcp_21 extends AbstractTestCaseServlet\n{\n    /* The variable below is used to drive control flow in the source function */\n    private boolean badPrivate = false;\n\n    public void bad(HttpServletRequest request, HttpServletResponse response) throws Throwable\n    {\n        String data;\n\n        badPrivate = true;\n        data = bad_source(request, response);\n\n        if (data != null)\n        {\n            /* POTENTIAL FLAW: Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS with strings like <scr<script>ipt> (CWE 182: Collapse of Data into Unsafe Value) */\n            response.getWriter().println(\"<br>bad(): data = \" + data.replaceAll(\"(<script>)\", \"\"));\n        }\n\n    }\n\n    private String bad_source(HttpServletRequest request, HttpServletResponse response) throws Throwable\n    {\n        String data;\n\n        if (badPrivate)\n        {\n            data = \"\"; /* Initialize data */\n            /* Read data using an outbound tcp connection */\n            {\n                Socket socket = null;\n                BufferedReader readerBuffered = null;\n                InputStreamReader readerInputStream = null;\n                try\n                {\n                    /* Read data using an outbound tcp connection */\n                    socket = new Socket(\"host.example.org\", 39544);\n                    /* read input from socket */\n                    readerInputStream = new InputStreamReader(socket.getInputStream(), \"UTF-8\");\n                    readerBuffered = new BufferedReader(readerInputStream);\n                    /* POTENTIAL FLAW: Read data using an outbound tcp connection */\n                    data = readerBuffered.readLine();\n                }\n                catch (IOException exceptIO)\n                {\n                    IO.logger.log(Level.WARNING, \"Error with stream reading\", exceptIO);\n                }\n                finally\n                {\n                    /* clean up stream reading objects */\n                    try\n                    {\n                        if (readerBuffered != null)\n                        {\n                            readerBuffered.close();\n                        }\n                    }\n                    catch (IOException exceptIO)\n                    {\n                        IO.logger.log(Level.WARNING, \"Error closing BufferedReader\", exceptIO);\n                    }\n\n                    try\n                    {\n                        if (readerInputStream != null)\n                        {\n                            readerInputStream.close();\n                        }\n                    }\n                    catch (IOException exceptIO)\n                    {\n                        IO.logger.log(Level.WARNING, \"Error closing InputStreamReader\", exceptIO);\n                    }\n\n                    /* clean up socket objects */\n                    try\n                    {\n                        if (socket != null)\n                        {\n                            socket.close();\n                        }\n                    }\n                    catch (IOException exceptIO)\n                    {\n                        IO.logger.log(Level.WARNING, \"Error closing Socket\", exceptIO);\n                    }\n                }\n            }\n        }\n        else\n        {\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run\n             * but ensure data is inititialized before the Sink to avoid compiler errors */\n            data = null;\n        }\n\n        return data;\n    }\n\n    /* The variables below are used to drive control flow in the source functions. */\n    private boolean goodG2B1_private = false;\n    private boolean goodG2B2_private = false;\n\n    public void good(HttpServletRequest request, HttpServletResponse response) throws Throwable\n    {\n        goodG2B1(request, response);\n        goodG2B2(request, response);\n    }\n\n    /* goodG2B1() - use goodsource and badsink by setting the variable to false instead of true */\n    private void goodG2B1(HttpServletRequest request, HttpServletResponse response) throws Throwable\n    {\n        String data;\n\n        goodG2B1_private = false;\n        data = goodG2B1_source(request, response);\n\n        if (data != null)\n        {\n            /* POTENTIAL FLAW: Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS with strings like <scr<script>ipt> (CWE 182: Collapse of Data into Unsafe Value) */\n            response.getWriter().println(\"<br>bad(): data = \" + data.replaceAll(\"(<script>)\", \"\"));\n        }\n\n    }\n\n    private String goodG2B1_source(HttpServletRequest request, HttpServletResponse response) throws Throwable\n    {\n        String data = null;\n\n        if (goodG2B1_private)\n        {\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run\n             * but ensure data is inititialized before the Sink to avoid compiler errors */\n            data = null;\n        }\n        else\n        {\n\n            /* FIX: Use a hardcoded string */\n            data = \"foo\";\n\n        }\n\n        return data;\n    }\n\n    /* goodG2B2() - use goodsource and badsink by reversing the blocks in the if in the sink function */\n    private void goodG2B2(HttpServletRequest request, HttpServletResponse response) throws Throwable\n    {\n        String data;\n\n        goodG2B2_private = true;\n        data = goodG2B2_source(request, response);\n\n        if (data != null)\n        {\n            /* POTENTIAL FLAW: Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS with strings like <scr<script>ipt> (CWE 182: Collapse of Data into Unsafe Value) */\n            response.getWriter().println(\"<br>bad(): data = \" + data.replaceAll(\"(<script>)\", \"\"));\n        }\n\n    }\n\n    private String goodG2B2_source(HttpServletRequest request, HttpServletResponse response) throws Throwable\n    {\n        String data = null;\n\n        if (goodG2B2_private)\n        {\n            /* FIX: Use a hardcoded string */\n            data = \"foo\";\n        }\n        else\n        {\n            /* INCIDENTAL: CWE 561 Dead Code, the code below will never run\n             * but ensure data is inititialized before the Sink to avoid compiler errors */\n            data = null;\n        }\n\n        return data;\n    }\n\n    /* Below is the main(). It is only used when building this testcase on\n     * its own for testing or for building a binary to use in testing binary\n     * analysis tools. It is not used when compiling all the testcases as one\n     * application, which is how source code analysis tools are tested.\n     */\n    public static void main(String[] args) throws ClassNotFoundException,\n           InstantiationException, IllegalAccessException\n    {\n        mainFromParent(args);\n    }\n\n}\n",
    "analyzed code": "1  \n2  \n3  \n4  \n5  \n6  \n7  \n8  \n9  \n10  \n11  \n12  \n13  \n14  \n15  \n16  \n17  package testcases.CWE80_XSS.s01;\n18  import testcasesupport.*;\n19  \n20  import javax.servlet.http.*;\n21  \n22  import java.io.BufferedReader;\n23  import java.io.InputStreamReader;\n24  import java.io.IOException;\n25  import java.net.Socket;\n26  \n27  import java.util.logging.Level;\n28  \n29  public class CWE80_XSS__CWE182_Servlet_connect_tcp_21 extends AbstractTestCaseServlet\n30  {\n31      \n32      private boolean hooPrivate = false;\n33  \n34      public void hoo(HttpServletRequest request, HttpServletResponse response) throws Throwable\n35      {\n36          String data;\n37  \n38          hooPrivate = true;\n39          data = hoo_source(request, response);\n40  \n41          if (data != null)\n42          {\n43              \n44              response.getWriter().println(\"<br>hoo(): data = \" + data.replaceAll(\"(<script>)\", \"\"));\n45          }\n46  \n47      }\n48  \n49      private String hoo_source(HttpServletRequest request, HttpServletResponse response) throws Throwable\n50      {\n51          String data;\n52  \n53          if (hooPrivate)\n54          {\n55              data = \"\"; \n56              \n57              {\n58                  Socket socket = null;\n59                  BufferedReader readerBuffered = null;\n60                  InputStreamReader readerInputStream = null;\n61                  try\n62                  {\n63                      \n64                      socket = new Socket(\"host.example.org\", 39544);\n65                      \n66                      readerInputStream = new InputStreamReader(socket.getInputStream(), \"UTF-8\");\n67                      readerBuffered = new BufferedReader(readerInputStream);\n68                      \n69                      data = readerBuffered.readLine();\n70                  }\n71                  catch (IOException exceptIO)\n72                  {\n73                      IO.logger.log(Level.WARNING, \"Error with stream reading\", exceptIO);\n74                  }\n75                  finally\n76                  {\n77                      \n78                      try\n79                      {\n80                          if (readerBuffered != null)\n81                          {\n82                              readerBuffered.close();\n83                          }\n84                      }\n85                      catch (IOException exceptIO)\n86                      {\n87                          IO.logger.log(Level.WARNING, \"Error closing BufferedReader\", exceptIO);\n88                      }\n89  \n90                      try\n91                      {\n92                          if (readerInputStream != null)\n93                          {\n94                              readerInputStream.close();\n95                          }\n96                      }\n97                      catch (IOException exceptIO)\n98                      {\n99                          IO.logger.log(Level.WARNING, \"Error closing InputStreamReader\", exceptIO);\n100                      }\n101  \n102                      \n103                      try\n104                      {\n105                          if (socket != null)\n106                          {\n107                              socket.close();\n108                          }\n109                      }\n110                      catch (IOException exceptIO)\n111                      {\n112                          IO.logger.log(Level.WARNING, \"Error closing Socket\", exceptIO);\n113                      }\n114                  }\n115              }\n116          }\n117          else\n118          {\n119              \n120  \n121              data = null;\n122          }\n123  \n124          return data;\n125      }\n126  \n127      \n128      private boolean fooxx1_private = false;\n129      private boolean fooxx2_private = false;\n130  \n131      public void foo(HttpServletRequest request, HttpServletResponse response) throws Throwable\n132      {\n133          fooxx1(request, response);\n134          fooxx2(request, response);\n135      }\n136  \n137      \n138      private void fooxx1(HttpServletRequest request, HttpServletResponse response) throws Throwable\n139      {\n140          String data;\n141  \n142          fooxx1_private = false;\n143          data = fooxx1_source(request, response);\n144  \n145          if (data != null)\n146          {\n147              \n148              response.getWriter().println(\"<br>hoo(): data = \" + data.replaceAll(\"(<script>)\", \"\"));\n149          }\n150  \n151      }\n152  \n153      private String fooxx1_source(HttpServletRequest request, HttpServletResponse response) throws Throwable\n154      {\n155          String data = null;\n156  \n157          if (fooxx1_private)\n158          {\n159              \n160  \n161              data = null;\n162          }\n163          else\n164          {\n165  \n166              \n167              data = \"foo\";\n168  \n169          }\n170  \n171          return data;\n172      }\n173  \n174      \n175      private void fooxx2(HttpServletRequest request, HttpServletResponse response) throws Throwable\n176      {\n177          String data;\n178  \n179          fooxx2_private = true;\n180          data = fooxx2_source(request, response);\n181  \n182          if (data != null)\n183          {\n184              \n185              response.getWriter().println(\"<br>hoo(): data = \" + data.replaceAll(\"(<script>)\", \"\"));\n186          }\n187  \n188      }\n189  \n190      private String fooxx2_source(HttpServletRequest request, HttpServletResponse response) throws Throwable\n191      {\n192          String data = null;\n193  \n194          if (fooxx2_private)\n195          {\n196              \n197              data = \"foo\";\n198          }\n199          else\n200          {\n201              \n202  \n203              data = null;\n204          }\n205  \n206          return data;\n207      }\n208  \n209      \n210  \n211  \n212  \n213  \n214      public static void main(String[] args) throws ClassNotFoundException,\n215             InstantiationException, IllegalAccessException\n216      {\n217          mainFromParent(args);\n218      }\n219  \n220  }\n221  ",
    "trace_check_results": [
        {
            "trace": [
                [
                    44,
                    "data"
                ]
            ],
            "result": {
                "type_sanitize": 0,
                "functionality_sanitize": 0,
                "order_sanitize": 0,
                "reachability_sanitize": 0,
                "total": 1,
                "final": 0
            }
        },
        {
            "trace": [
                [
                    148,
                    "data"
                ]
            ],
            "result": {
                "type_sanitize": 0,
                "functionality_sanitize": 0,
                "order_sanitize": 0,
                "reachability_sanitize": 0,
                "total": 1,
                "final": 0
            }
        }
    ]
}