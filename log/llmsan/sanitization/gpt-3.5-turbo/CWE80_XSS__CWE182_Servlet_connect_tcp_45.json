{
    "original code": "/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE80_XSS__CWE182_Servlet_connect_tcp_45.java\nLabel Definition File: CWE80_XSS__CWE182_Servlet.label.xml\nTemplate File: sources-sink-45.tmpl.java\n*/\n/*\n * @description\n * CWE: 80 Cross Site Scripting (XSS)\n * BadSource: connect_tcp Read data using an outbound tcp connection\n * GoodSource: A hardcoded string\n * Sinks:\n *    BadSink : Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS (CWE 182: Collapse of Data into Unsafe Value)\n * Flow Variant: 45 Data flow: data passed as a private class member variable from one function to another in the same class\n *\n * */\n\npackage testcases.CWE80_XSS.s01;\nimport testcasesupport.*;\n\nimport javax.servlet.http.*;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.net.Socket;\n\nimport java.util.logging.Level;\n\npublic class CWE80_XSS__CWE182_Servlet_connect_tcp_45 extends AbstractTestCaseServlet\n{\n    private String dataBad;\n    private String dataGoodG2B;\n\n    private void badSink(HttpServletRequest request, HttpServletResponse response) throws Throwable\n    {\n        String data = dataBad;\n\n        if (data != null)\n        {\n            /* POTENTIAL FLAW: Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS with strings like <scr<script>ipt> (CWE 182: Collapse of Data into Unsafe Value) */\n            response.getWriter().println(\"<br>bad(): data = \" + data.replaceAll(\"(<script>)\", \"\"));\n        }\n\n    }\n\n    /* uses badsource and badsink */\n    public void bad(HttpServletRequest request, HttpServletResponse response) throws Throwable\n    {\n        String data;\n\n        data = \"\"; /* Initialize data */\n\n        /* Read data using an outbound tcp connection */\n        {\n            Socket socket = null;\n            BufferedReader readerBuffered = null;\n            InputStreamReader readerInputStream = null;\n\n            try\n            {\n                /* Read data using an outbound tcp connection */\n                socket = new Socket(\"host.example.org\", 39544);\n\n                /* read input from socket */\n\n                readerInputStream = new InputStreamReader(socket.getInputStream(), \"UTF-8\");\n                readerBuffered = new BufferedReader(readerInputStream);\n\n                /* POTENTIAL FLAW: Read data using an outbound tcp connection */\n                data = readerBuffered.readLine();\n            }\n            catch (IOException exceptIO)\n            {\n                IO.logger.log(Level.WARNING, \"Error with stream reading\", exceptIO);\n            }\n            finally\n            {\n                /* clean up stream reading objects */\n                try\n                {\n                    if (readerBuffered != null)\n                    {\n                        readerBuffered.close();\n                    }\n                }\n                catch (IOException exceptIO)\n                {\n                    IO.logger.log(Level.WARNING, \"Error closing BufferedReader\", exceptIO);\n                }\n\n                try\n                {\n                    if (readerInputStream != null)\n                    {\n                        readerInputStream.close();\n                    }\n                }\n                catch (IOException exceptIO)\n                {\n                    IO.logger.log(Level.WARNING, \"Error closing InputStreamReader\", exceptIO);\n                }\n\n                /* clean up socket objects */\n                try\n                {\n                    if (socket != null)\n                    {\n                        socket.close();\n                    }\n                }\n                catch (IOException exceptIO)\n                {\n                    IO.logger.log(Level.WARNING, \"Error closing Socket\", exceptIO);\n                }\n            }\n        }\n\n        dataBad = data;\n        badSink(request, response);\n    }\n\n    public void good(HttpServletRequest request, HttpServletResponse response) throws Throwable\n    {\n        goodG2B(request, response);\n    }\n\n    private void goodG2BSink(HttpServletRequest request, HttpServletResponse response) throws Throwable\n    {\n        String data = dataGoodG2B;\n\n        if (data != null)\n        {\n            /* POTENTIAL FLAW: Display of data in web page after using replaceAll() to remove script tags, which will still allow XSS with strings like <scr<script>ipt> (CWE 182: Collapse of Data into Unsafe Value) */\n            response.getWriter().println(\"<br>bad(): data = \" + data.replaceAll(\"(<script>)\", \"\"));\n        }\n\n    }\n\n    /* goodG2B() - use goodsource and badsink */\n    private void goodG2B(HttpServletRequest request, HttpServletResponse response) throws Throwable\n    {\n        String data;\n\n        /* FIX: Use a hardcoded string */\n        data = \"foo\";\n\n        dataGoodG2B = data;\n        goodG2BSink(request, response);\n    }\n\n    /* Below is the main(). It is only used when building this testcase on\n     * its own for testing or for building a binary to use in testing binary\n     * analysis tools. It is not used when compiling all the testcases as one\n     * application, which is how source code analysis tools are tested.\n     */\n    public static void main(String[] args) throws ClassNotFoundException,\n           InstantiationException, IllegalAccessException\n    {\n        mainFromParent(args);\n    }\n}\n",
    "analyzed code": "1  \n2  \n3  \n4  \n5  \n6  \n7  \n8  \n9  \n10  \n11  \n12  \n13  \n14  \n15  \n16  \n17  package testcases.CWE80_XSS.s01;\n18  import testcasesupport.*;\n19  \n20  import javax.servlet.http.*;\n21  \n22  import java.io.BufferedReader;\n23  import java.io.InputStreamReader;\n24  import java.io.IOException;\n25  import java.net.Socket;\n26  \n27  import java.util.logging.Level;\n28  \n29  public class CWE80_XSS__CWE182_Servlet_connect_tcp_45 extends AbstractTestCaseServlet\n30  {\n31      private String dataBad;\n32      private String dataGoodxx;\n33  \n34      private void hooSink(HttpServletRequest request, HttpServletResponse response) throws Throwable\n35      {\n36          String data = dataBad;\n37  \n38          if (data != null)\n39          {\n40              \n41              response.getWriter().println(\"<br>hoo(): data = \" + data.replaceAll(\"(<script>)\", \"\"));\n42          }\n43  \n44      }\n45  \n46      \n47      public void hoo(HttpServletRequest request, HttpServletResponse response) throws Throwable\n48      {\n49          String data;\n50  \n51          data = \"\"; \n52  \n53          \n54          {\n55              Socket socket = null;\n56              BufferedReader readerBuffered = null;\n57              InputStreamReader readerInputStream = null;\n58  \n59              try\n60              {\n61                  \n62                  socket = new Socket(\"host.example.org\", 39544);\n63  \n64                  \n65  \n66                  readerInputStream = new InputStreamReader(socket.getInputStream(), \"UTF-8\");\n67                  readerBuffered = new BufferedReader(readerInputStream);\n68  \n69                  \n70                  data = readerBuffered.readLine();\n71              }\n72              catch (IOException exceptIO)\n73              {\n74                  IO.logger.log(Level.WARNING, \"Error with stream reading\", exceptIO);\n75              }\n76              finally\n77              {\n78                  \n79                  try\n80                  {\n81                      if (readerBuffered != null)\n82                      {\n83                          readerBuffered.close();\n84                      }\n85                  }\n86                  catch (IOException exceptIO)\n87                  {\n88                      IO.logger.log(Level.WARNING, \"Error closing BufferedReader\", exceptIO);\n89                  }\n90  \n91                  try\n92                  {\n93                      if (readerInputStream != null)\n94                      {\n95                          readerInputStream.close();\n96                      }\n97                  }\n98                  catch (IOException exceptIO)\n99                  {\n100                      IO.logger.log(Level.WARNING, \"Error closing InputStreamReader\", exceptIO);\n101                  }\n102  \n103                  \n104                  try\n105                  {\n106                      if (socket != null)\n107                      {\n108                          socket.close();\n109                      }\n110                  }\n111                  catch (IOException exceptIO)\n112                  {\n113                      IO.logger.log(Level.WARNING, \"Error closing Socket\", exceptIO);\n114                  }\n115              }\n116          }\n117  \n118          dataBad = data;\n119          hooSink(request, response);\n120      }\n121  \n122      public void foo(HttpServletRequest request, HttpServletResponse response) throws Throwable\n123      {\n124          fooxx(request, response);\n125      }\n126  \n127      private void fooxxSink(HttpServletRequest request, HttpServletResponse response) throws Throwable\n128      {\n129          String data = dataGoodxx;\n130  \n131          if (data != null)\n132          {\n133              \n134              response.getWriter().println(\"<br>hoo(): data = \" + data.replaceAll(\"(<script>)\", \"\"));\n135          }\n136  \n137      }\n138  \n139      \n140      private void fooxx(HttpServletRequest request, HttpServletResponse response) throws Throwable\n141      {\n142          String data;\n143  \n144          \n145          data = \"foo\";\n146  \n147          dataGoodxx = data;\n148          fooxxSink(request, response);\n149      }\n150  \n151      \n152  \n153  \n154  \n155  \n156      public static void main(String[] args) throws ClassNotFoundException,\n157             InstantiationException, IllegalAccessException\n158      {\n159          mainFromParent(args);\n160      }\n161  }\n162  ",
    "trace_check_results": [
        {
            "trace": [
                [
                    70,
                    "data"
                ],
                [
                    118,
                    "data"
                ],
                [
                    41,
                    "data"
                ]
            ],
            "result": {
                "type_sanitize": 1,
                "functionality_sanitize": 1,
                "order_sanitize": 1,
                "reachability_sanitize": 1,
                "total": 1,
                "final": 1
            }
        }
    ]
}